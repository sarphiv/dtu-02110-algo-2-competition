#pragma once
#include <vector>
#include <tuple>

// #include "robin_map.h"
#include <unordered_map>

#include "common.hpp"



using node_capacity_t = unsigned long long;
using node_idx_t = unsigned int;
// NOTE: The below trick to find the max only works 
//  if the capacity type is unsigned.
#define NODE_CAPACITY_MAX ((node_capacity_t)-2)
#define NODE_IDX_MAX ((node_idx_t)-2)


class FlowGraph
{
private:
    struct Edge
    {
        // Capacity forwards
        node_capacity_t capacity;
        // Node index of end node
        node_idx_t end;
        // Index of vector for reverse residual edge
        //  capacity[end][reverse_idx] gives reverse edge.
        node_idx_t reverse_outgoing_idx;
    };

    struct pair_hash {
        // FROM: https://stackoverflow.com/a/27952689
        // FROM: https://stackoverflow.com/a/32685618
        template <class T>
        std::size_t operator()(const std::pair<T, T>& p) const {
            const auto hash = std::hash<T>{};
            const auto h1 = hash(p.first);
            const auto h2 = hash(p.second);

            // return h1 ^ (h2 + 0x9e3779b9 + (h1 << 6) + (h1 >> 2));
            return 30197 * h1 * h2;
        }
    };


    const std::vector<ZoneInfo>& zones;
    const node_idx_t source, terminal;
    const node_idx_t node_last;

    std::vector<node_idx_t> height;
    std::vector<node_capacity_t> excess;
    // Map from node index to vector of outgoing edges
    // tsl::robin_map<node_idx_t, std::vector<Edge>> capacity;
    std::unordered_map<node_idx_t, std::vector<Edge>> capacity;
    // Map from (start, end) to vector index of outgoing capacity
    // NOTE: Used while adding edges to avoid searching inner capacity vector
    // tsl::robin_map<std::pair<node_idx_t, node_idx_t>, node_idx_t, pair_hash> outgoing_idx;
    std::unordered_map<std::pair<node_idx_t, node_idx_t>, node_idx_t, pair_hash> outgoing_idx;


    void push
    (
        node_capacity_t* start_cap, node_capacity_t* end_cap,
        node_capacity_t* start_exs, node_capacity_t* end_exs
    );

    void relabel(node_idx_t* height, const std::vector<Edge> &outgoing);

    std::vector<node_idx_t> max_height_nodes();


public:
    FlowGraph() = default;
    FlowGraph(const std::vector<ZoneInfo>& zones, const zone_idx_t source, const zone_idx_t terminal);


    node_idx_t get_input(zone_idx_t zone_idx)
    {
        return (node_idx_t)zone_idx * (ZONE_OBSTACLE_SIZE + 1);
    }

    node_idx_t get_output(zone_idx_t zone_idx, zone_obstacle_val_t obstacle)
    {
        return (node_idx_t)zone_idx * (ZONE_OBSTACLE_SIZE + 1) + 1 + (node_idx_t)obstacle;
    }


    void add_zone_edge
    (
        const zone_idx_t start, 
        const zone_idx_t end, 
        const ZoneObstacle obstacle,
        const zone_capacity_t capacity
    );

    void add_node_edge
    (
        const node_idx_t start, 
        const node_idx_t end, 
        const node_capacity_t capacity
    );


    node_capacity_t calculate_maximum_flow();
};